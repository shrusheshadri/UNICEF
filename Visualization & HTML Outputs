import matplotlib.pyplot as plt
import numpy as np
import base64
from io import BytesIO
import pandas as pd
import re

# Re-calculate weighted averages to ensure they are available
# This code is copied from cell db1a1283 which successfully calculated the weighted averages

# Reload demographic data with the correct header (row 0) and rename columns
df_demographic = pd.read_excel("/content/WPP2022_GEN_F01_DEMOGRAPHIC_INDICATORS_COMPACT_REV1.xlsx", header=0)

# Rename columns to be more descriptive
df_demographic.rename(columns={'Region, subregion, country or area *': 'Country', 'Births (thousands)': '2022_projected_births'}, inplace=True)

# Standardize country names in demographic data
df_demographic['Country'] = df_demographic['Country'].astype(str).str.strip().str.lower()

# Remove irrelevant entries from demographic data (based on previous cleaning steps and inspection)
demographic_irrelevant_more = [
    'index', 'variant', 'notes', 'location code', 'iso3 alpha-code', 'iso2 alpha-code', 'sdmx code**', 'type', 'parent code',
    'file gen/01/rev1: demographic indicators by region, subregion, country or area',
    'estimates, 1950 - 2021',
    'pop/db/wpp/rev.2022/gen/f01/rev.1',
    'Â© july 2022 by united nations, made available under a creative commons license cc by 3.0 igo: http://creativecommons.org/licenses/by/3.0/igo/',
    'suggested citation: united nations, department of economic and social affairs, population division (2022). world population prospects 2022, online edition.',
    'note: regional aggregates are based on the latest available country classification.',
    'population', 'fertility', 'mortality', 'migration' # Remove the aggregated header rows
]
df_demographic = df_demographic[~df_demographic['Country'].isin(demographic_irrelevant_more)]

# Remove filtering by 'Type' == 'Country' to retain necessary rows
if 'Type' in df_demographic.columns:
     df_demographic = df_demographic[df_demographic['Type'] == 'Country']


df_demographic = df_demographic.dropna(subset=['Country'])


# Load the other two dataframes (assuming they are already cleaned from previous steps)
df_global_dataflow = pd.read_excel("/GLOBAL_DATAFLOW_2018-2022.xlsx", header=1)
df_on_track = pd.read_excel("/On-track and off-track countries.xlsx")

# Clean and standardize country identifiers for global dataflow and on-track data (re-execute cleaning)
df_global_dataflow.rename(columns={'Geographic area': 'Country'}, inplace=True)
df_on_track.rename(columns={'OfficialName': 'Country'}, inplace=True)

df_global_dataflow['Country'] = df_global_dataflow['Country'].astype(str).str.strip().str.lower()
df_on_track['Country'] = df_on_track['Country'].astype(str).str.strip().str.lower()


# Remove parenthesized text and leading/trailing spaces from df_global_dataflow (re-execute cleaning)
df_global_dataflow['Country'] = df_global_dataflow['Country'].apply(lambda x: re.sub(r'\(.*?\)', '', str(x)).strip() if pd.notna(x) else x)

# Remove rows from df_global_dataflow that are not countries (re-execute cleaning)
regions_to_remove = ['africa', 'african union', 'americas', 'anguilla', 'arab maghreb union (amu)', 'arab states', 'asia and the pacific', 'caribbean', 'central africa (african union)', 'central america', 'central asia', 'central and southern asia', 'common market for eastern and southern africa (comesa)', 'community of sahel-Saharan states (cen-sad)', 'east african community (eac)', 'east asia and pacific', 'east and southern africa', 'eastern africa', 'eastern africa (african union)', 'eastern asia', 'eastern europe and central asia', 'eastern mediterranean', 'eastern and south-eastern asia', 'eastern and southern africa', 'economic community of central african states (eccas)', 'economic community of west african states (ecowas 2025)', 'economic community of west African states (ECOWAS)', 'europe', 'europe and central asia', 'intergovernmental authority on development (igad)', 'latin america and the caribbean', 'least developed countries (ldc)', 'middle africa', 'middle east and north africa', 'north america', 'northern africa', 'northern africa (african union)', 'northern africa and western asia', 'northern america', 'oceania', 'oceania (exc. australia and new zealand)', 'sdg regions - global', 'south america', 'south asia', 'south sudan', 'south-east asia', 'south-eastern asia', 'southern africa', 'southern africa (african union)', 'southern african development community (sadc)', 'southern asia', 'sub-saharan africa', 'unicef programme regions - global', 'unicef reporting regions - global', 'west and central africa', 'western africa', 'western africa (african union)', 'western asia', 'western europe', 'western pacific', 'world bank (high income)', 'world bank (low income)', 'world bank (lower middle income)', 'world bank (upper middle income)', 'footnotes', 'unit multiplier: units', 'unit of measure: %', 'observation confidentaility: free', 'time period activity related to when the da', 'current age: 15 to 49 years old']

df_global_dataflow = df_global_dataflow[~df_global_dataflow['Country'].isin(regions_to_remove)]

regions_to_remove_further = ['central africa', 'north africa', 'united nations economic commission for africa', 'west africa', 'arab maghreb union', 'common market for eastern and southern africa', 'community of sahel-Saharan states', 'east african community', 'economic community of central african states', 'economic community of west african states', 'intergovernmental authority on development', 'least developed countries', 'southern african development community', 'world bank', 'time period activity related to when the data are collected: end of fieldwork']

df_global_dataflow = df_global_dataflow[~df_global_dataflow['Country'].isin(regions_to_remove_further)]

df_global_dataflow = df_global_dataflow.dropna(subset=['Country'])
df_on_track = df_on_track.dropna(subset=['Country'])


# Filter and select recent data - re-execute
df_global_dataflow_filtered = df_global_dataflow[
    df_global_dataflow['Indicator'].isin([
        'Antenatal care 4+ visits - percentage of women (aged 15-49 years) attended at least four times during pregnancy by any provider',
        'Skilled birth attendant - percentage of deliveries attended by skilled health personnel'
    ])
]

df_melted = df_global_dataflow_filtered.melt(
    id_vars=['Country', 'Indicator', 'Sex'],
    value_vars=['Unnamed: 3', 'Unnamed: 4', 'Unnamed: 5', 'Unnamed: 6', 'Unnamed: 7'],
    var_name='Year_col',
    value_name='Value'
)

year_map = {
    'Unnamed: 3': 2018,
    'Unnamed: 4': 2019,
    'Unnamed: 5': 2020,
    'Unnamed: 6': 2021,
    'Unnamed: 7': 2022
}

df_melted['Year'] = df_melted['Year_col'].map(year_map)

df_melted.dropna(subset=['Value'], inplace=True)
df_melted['Value'] = pd.to_numeric(df_melted['Value'], errors='coerce')
df_melted.dropna(subset=['Value'], inplace=True)

df_melted_sorted = df_melted.sort_values(by=['Country', 'Indicator', 'Year'], ascending=[True, True, False])
df_most_recent = df_melted_sorted.drop_duplicates(subset=['Country', 'Indicator'], keep='first')

df_pivot = df_most_recent.pivot(index='Country', columns='Indicator', values='Value')


# Merge the dataframes
df_merged = pd.merge(df_pivot, df_on_track, on='Country', how='outer')
df_merged = pd.merge(df_merged, df_demographic[['Country', '2022_projected_births']], on='Country', how='outer')

# Calculate population-weighted averages
# Convert '2022_projected_births' to numeric, coercing errors
df_merged['2022_projected_births'] = pd.to_numeric(df_merged['2022_projected_births'], errors='coerce')

# Define the coverage columns
coverage_cols = [
    'Antenatal care 4+ visits - percentage of women (aged 15-49 years) attended at least four times during pregnancy by any provider',
    'Skilled birth attendant - percentage of deliveries attended by skilled health personnel'
]

# Calculate weighted average for each group in 'Status.U5MR'
weighted_averages = {}
for status in df_merged['Status.U5MR'].unique():
    if pd.notna(status):
        group_df = df_merged[df_merged['Status.U5MR'] == status].copy()
        weighted_averages[status] = {}
        for col in coverage_cols:
            # Drop rows with missing coverage or zero/missing population
            valid_data = group_df.dropna(subset=[col, '2022_projected_births']).copy()
            valid_data = valid_data[valid_data['2022_projected_births'] > 0]

            if not valid_data.empty:
                weighted_avg = (valid_data[col] * valid_data['2022_projected_births']).sum() / valid_data['2022_projected_births'].sum()
                weighted_averages[status][col] = weighted_avg
            else:
                weighted_averages[status][col] = None

# Replace None values in weighted_averages with 0 for plotting
for status in weighted_averages:
    for indicator in weighted_averages[status]:
        if weighted_averages[status][indicator] is None:
            weighted_averages[status][indicator] = 0


# Prepare data for plotting
statuses = list(weighted_averages.keys())
anc4_coverage = [weighted_averages[status].get('Antenatal care 4+ visits - percentage of women (aged 15-49 years) attended at least four times during pregnancy by any provider', 0) for status in statuses]
sba_coverage = [weighted_averages[status].get('Skilled birth attendant - percentage of deliveries attended by skilled health personnel', 0) for status in statuses]

x = np.arange(len(statuses))  # the label locations
width = 0.35  # the width of the bars

fig, ax = plt.subplots(figsize=(10, 6))
rects1 = ax.bar(x - width/2, anc4_coverage, width, label='ANC4+ Coverage')
rects2 = ax.bar(x + width/2, sba_coverage, width, label='SBA Coverage')

# Add some text for labels, title and custom x-axis tick labels, etc.
ax.set_ylabel('Population-Weighted Coverage (%)')
ax.set_title('Population-Weighted Coverage by U5MR Status')
ax.set_xticks(x)
ax.set_xticklabels(statuses)
ax.legend()

# Add value labels on top of the bars
def autolabel(rects):
    """Attach a text label above each bar in *rects*, displaying its height."""
    for rect in rects:
        height = rect.get_height()
        # Only add label if height is not zero
        if height > 0:
            ax.annotate(f'{height:.1f}',
                        xy=(rect.get_x() + rect.get_width() / 2, height),
                        xytext=(0, 3),  # 3 points vertical offset
                        textcoords="offset points",
                        ha='center', va='bottom')

autolabel(rects1)
autolabel(rects2)

fig.tight_layout()

# Save the plot to a BytesIO object
buf = BytesIO()
plt.savefig(buf, format='png')
plt.close(fig)  # Close the plot to prevent it from displaying twice
data = base64.b64encode(buf.getvalue()).decode('utf-8')
buf.close()

# Interpretation paragraph (same as the previous response)
interpretation = """
The visualization displays the population-weighted averages for Antenatal Care (ANC4+) and Skilled Birth Attendant (SBA) coverage across countries grouped by their Under-Five Mortality Rate (U5MR) status: 'Acceleration Needed', 'Achieved', and 'On Track'. The 'Achieved' group, representing countries that have met their U5MR reduction targets, shows the highest population-weighted coverage for both ANC4+ and SBA. The 'On Track' group, making sufficient progress, also exhibits relatively high coverage. Conversely, the 'Acceleration Needed' group, which are not on track to meet their U5MR targets, demonstrates the lowest population-weighted coverage for both indicators. This suggests a strong correlation between higher levels of maternal and child health service coverage and better progress in reducing under-five mortality. A key caveat is that these are population-weighted averages, meaning countries with larger populations have a greater influence on the average for their respective groups. Additionally, the analysis relies on the availability and quality of data for each indicator and the accuracy of the U5MR status classifications and 2022 projected births data. Missing data for some countries or indicators could impact the weighted averages.
"""

# Generate HTML output
html_output = f"""
<!DOCTYPE html>
<html>
<head>
<title>Population-Weighted Coverage Report</title>
</head>
<body>
    <h1>Population-Weighted Coverage by U5MR Status</h1>
    <img src="data:image/png;base64,{data}" alt="Population-Weighted Coverage by U5MR Status Bar Chart">
    <h2>Interpretation of Results</h2>
    <p>{interpretation}</p>
</body>
</html>
"""

# Display the HTML output
from IPython.display import HTML, display
display(HTML(html_output))
